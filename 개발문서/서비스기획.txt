---

## 1) 기본 아이디어 흐름 및 필요 데이터

1. **사용자 입력(교열 전 기사)**

   * 사용자가 작성한 원문 기사를 입력받습니다.

2. **두 가지 교열 결과 생성**

   * Prompt 엔지니어링(프롬프트1 / 프롬프트2)으로 **두 가지 버전**의 교열 결과를 얻습니다.
   * 이때 **LLM**(또는 교정기)에게 각각 다른 스킬/지침/스타일을 적용해 결과를 내도록 설정하는 식이죠.

3. **사용자 선택**

   * 사용자는 프롬프트1 결과와 프롬프트2 결과 중 원하는 것을 선택합니다.
   * 어떤 결과를 택했는지에 대한 **피드백**이 중요합니다.

4. **맞춤형 시스템으로 고도화**

   * 선택된 결과 + 사용자 피드백을 DB에 저장하고, 이를 **학습/분석**에 활용합니다.
   * 자주 선택되는 교열 패턴, 문체, 잘 안 쓰이는 교정안 등을 통계적으로 축적하면, **개인화**된 교열 제안을 지속적으로 개선할 수 있습니다.

---

## 2) MongoDB + RAG + Prompt Engineering 구조

### (1) MongoDB를 활용한 데이터 관리

* **문서 스키마** 예시:

  1. **교열 요청 내역(articles)**

     * \_id, 사용자 ID(또는 익명), 원문 기사, 제출 시각, 기타 메타데이터(작성 주제, 분야 등)
  2. **교열 결과(corrections)**

     * \_id, 교열 요청 \_id(참조), 프롬프트 종류(1 or 2), 교열 후 텍스트, 생성 시각, LLM 메타정보(모델, 버전 등)
  3. **사용자 선택(user\_choices)**

     * 요청 \_id, 최종선택(프롬프트1/2 중 어느 것인가), 선택 시각, 사용자 별점·코멘트 등

이렇게 **교열 전 → 교열 결과 → 사용자 선택**으로 테이블(콜렉션)을 구분하면, 나중에 어떤 프롬프트가 더 많이 선택됐는지, 어떤 문체가 선호되는지 등을 분석하기 쉽습니다.

### (2) RAG(Retrieval Augmented Generation) 방식

* **스타일북** 등 대용량 규칙 문서를 한 번에 통째로 프롬프트에 실으면, 토큰 수 문제와 비용 증가가 발생합니다.
* RAG를 적용하면:

  * (가) 스타일북을 MongoDB나 벡터 DB(예: Elastic + dense-vector, Faiss, Pinecone 등)에 섹션/문단 단위로 저장
  * (나) “사용자 기사”에 대한 키워드·벡터 검색을 실행해 관련된 규칙 문단만 추출
  * (다) 추출된 텍스트를 프롬프트에 동적으로 삽입해 교열 결과 도출
* 이렇게 하면 “필요한 규칙 정보만” LLM에 주기 때문에 효율적이고, 컨텍스트 윈도우도 절약됩니다.

### (3) Prompt Engineering 기법 내장

* 예: 프롬프트1은 **“최소한의 간결한 교열”** 위주, 프롬프트2는 **“문체/어휘까지 적극 개입해서 다듬기”** 같은 식으로 성격을 다르게 줍니다.
* MongoDB나 별도 설정 파일(예: YAML/JSON)에, **프롬프트 템플릿**을 저장해두고 필요 시 동적으로 불러와서 적용해 볼 수 있겠죠.
* 향후 ‘사용자 선호’가 쌓이면, “어느 사용자는 프롬프트2 스타일을 더 좋아한다” 식으로 개인화된 프롬프트를 추천할 수도 있습니다.

---

## 3) 고도화 포인트

1. **피드백 루프**

   * 사용자들이 직접 교열 결과에 대해 별점(1\~5)이나 간단한 후기(“이 부분은 너무 딱딱해요” 등)를 추가로 남길 수 있게 하면, 모델/프롬프트 개선에 큰 도움이 됩니다.

2. **자동 평가 지표 도입**

   * 가능하다면, 맞춤법 검사 결과(오류가 얼마나 수정되었는지), 비문율, 문장 길이 등 **객관적 수치**를 산출하는 로직을 추가하면 품질 측정에 유리합니다.

3. **개인화/맞춤형 추천**

   * 같은 기사를 2\~3번 교열하는 패턴 분석 → “사용자의 기사 스타일”에 맞춰 다음부터는 처음부터 프롬프트2를 우선순위로 제공 등 자동화.

4. **버전 관리**

   * 교열 규칙(스타일북)이나 LLM, 프롬프트 템플릿도 계속 변할 수 있습니다.
   * 버전 히스토리를 잘 관리해두면, “어느 버전의 규칙을 적용했을 때는 오류율이 어떠했는지” 같은 비교가 가능합니다.

---

## 4) 전반적인 평가

* **MVP 측면**:

  * 사용자 관점에서 “교열 전 기사를 입력한다 → 두 가지 결과 중 하나 골라본다”라는 프로세스만 있어도, 이미 **명확하고 직관적인 사용자 흐름**을 갖습니다.
  * 빠르게 프로토타입을 만들고 피드백을 모으는 데 매우 유효합니다.

* **확장성 측면**:

  * MongoDB로 데이터를 일관성 있게 저장하고, 각 결과에 대한 사용자 피드백까지 함께 축적 → 이후 데이터 분석 / 모델 개선 루프로 연결.
  * RAG 방식으로 스타일북 같은 대규모 편집규정 문서를 효율적으로 참조 → 한국어 교열이 가능해집니다.

* **기술 난이도**:

  * 처음에는 LLM API(또는 오픈소스 모델) + MongoDB + 간단한 검색(혹은 벡터 DB)만 구현해도 충분.
  * 추후 벡터 DB/NER(개체명 인식)/전문 NLP 라이브러리 추가 등으로 확장 가능.

